
# 2020's Best Practice pillars for the Java ecosystem
#### (title continued...) relative to Java from '00s, from Manager's POV, with examples. Plus a few bad practices
by Vic Cekvenich


### Background

I am Vic Cekvenich, my claim to fame is writing the first book on Java Struts, a predecessor to Spring Boot. I have been looking at Apache Spark, Akka, etc. and I think we can do better, specially as polyglot. There are few ideas we can leverage from NodeJS's Express library. 
And by better I might easier and faster. So lets review the 2020's Best Practice pillars for the Java ecosystem! 

## #1. Scala, Kotlin, Groovy
SDKMan, Scala, and Java 11 are incremental improvements for the 2020's Java ecosystem.

Kotlin is JVM default used for Google's Andorid platform. Scala is popular for Data Science. And Groovy is dynamic, like NodeJS and Python.
All 3 are more concise than Java for writing applications, utilities, etc. Of the 3 Scala seems easiest to adopt, you can for example go online and paste Java code and it will be converted to Scala. But when writing a library, it is better to write it in Java, so it can be used by others on the JVM platform. 

In 2020's we install Java 11 LTS via SDKMan, and run simply the app via:

```
	java -jar app1.jar
``` 

Oh, an why be JVM based? Because JVM is better then C++, the closest alternative. (One example of why C++ is bad is that trillion dollar F35 plane is a failure, and it was written in C++)


## #2: DB in RAM Memory

DB's using RAM is a new and revolutionary improvment.

Before the 2020's a DB (SQL, Object, FTS, Graph, etc.) would be stored on an SSD, NVMe, SSD, etc. 
But now cloud providers have machines that have 512 Gigs of RAM and more, and even terabytes of RAM is available. And RAM is much faster than SSDs. 
And if terabytes if to small for your DB? You can cluster you DB cloud containers and combine several DB servers into one any size you need.

We can still use cheap S3 type storage to dump things. But for HFT, AdTech, Data Science and such: we can and should store in RAM. 

Our old friend REDIS works well, as does SQLite. SQLite works in RAM, or can have temp tables in RAM for materialized views.

Our new friends include Aerospkie, Spark, Clickhouse, Apache Ignite, etc. 

This is a a paradigm shift, and requires learning and internalizing. So not only should your cloud VM's be 512 Gig or RAM or more, your local development machine should also have 128Gig of RAM or more. (Some development workstation examples with 128Gig plus or RAM: iMac Pro, System 76 and Digital Tigers).

## #3: Tools: Gradle.build, Jitpack, Cloud IDE.

Before the '20's, we used to use POM.xml. The improvement is self evident with gradle.build.

Compare the power, here a build.gradle that publishes a jar to Jitpack, so you can use the jar in apps via gradle (or maven). Once published, you can now use your lib anywhere in the JVM ecosystem. It is self evident how  much easier the new way is compared to what we had to deal with publishing with XML to Maven:

```
buildscript {
  repositories {
    maven { url "https://jitpack.io" }
  }
  dependencies {
    classpath 'com.github.jengelman.gradle.plugins:shadow:5.2.0'
  }
}
plugins { id 'com.github.johnrengelman.shadow' version '5.2.0' }

apply plugin: 'com.github.johnrengelman.shadow'
repositories {
	maven { url 'https://jitpack.io' }
    mavenCentral()
}
dependencies { }
archivesBaseName = 'XXX'
shadowJar {
   baseName = 'XXX'
   classifier = '' archiveVersion = ''
}
tasks.build.dependsOn tasks.shadowJar
artifacts { archives shadowJar }
// needs jitpack.yaml in root for java version and gradle for its version
group = 'com.github.jitpack'

```

Also, before the '20s we started deploying to cloud. Now our IDE can be in the cloud also, eg: CodeAnywhere.


#### Simple build scripts



##### Example: Using Scala, insert into DB. Maximum Inserts per second.


#### Forced sharding

#### Blue-Green Deployments

#### To master new way you must absorb the tools

## 4 JAR, not WAR

#### Netty

## 5 Iron Cloud

## 6 Load testing

#### And Monitoring

#### Doug Lea

## 7 Client-side View Model, Auth and more

## 8 SSR (Server Side Rendering) with Pug

### Like NodeJS's Express

## 9 QUnit

##### Example: Test the API/VM

## 10 Edge (no https)

#### Topology aware client, DNS and Edge processing

## 11 Back pressure

## 12 Hiring


# Bad smells

## A. Hitchen's Razor & bombastic executive adjectives


#### Fake Big Data 


#### 30X faster. MemSQL



#### Impossible to overstate


## B. 'No XML Assholes'

#### Channeling Linus

#### Rod Johnson hints to reduce XML

#### Alternatives: Front-End, Python, Node.js, Go

#### Logging in Java

## C. Interruptions, like Slack

At home, checking work email.

#### Rengnogled 

## Conclusion

Are you an experienced Java tech leader?
If so:

- I listed 12 good particles. Is there a 13th?

- I listed 2 bad practices. Is the a 3rd?

- And most important: is there anything I should remove!

Reach out to me please and help me. vic(at) eml.cc
